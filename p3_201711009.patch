diff --git a/Makefile b/Makefile
index 153526e..15e3356 100644
--- a/Makefile
+++ b/Makefile
@@ -182,6 +182,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_secondtest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -250,7 +251,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c secondtest.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/defs.h b/defs.h
index 9b6315d..dd12899 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+void            pvminfo(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
@@ -173,7 +174,7 @@ void            uartputc(int);
 // vm.c
 void            seginit(void);
 void            kvmalloc(void);
-pde_t*          setupkvm(void);
+pde_t*          setupkvm(int);
 char*           uva2ka(pde_t*, char*);
 int             allocuvm(pde_t*, uint, uint);
 int             deallocuvm(pde_t*, uint, uint);
@@ -186,6 +187,7 @@ void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
 void            pagefault(void);
+void            printvm(pde_t *pgdir);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/exec.c b/exec.c
index 98a2946..274bcdd 100644
--- a/exec.c
+++ b/exec.c
@@ -35,7 +35,7 @@ exec(char *path, char **argv)
   if(elf.magic != ELF_MAGIC)
     goto bad;
 
-  if((pgdir = setupkvm()) == 0)
+  if((pgdir = setupkvm(1)) == 0)
     goto bad;
 
   // Load program into memory.
@@ -96,7 +96,7 @@ exec(char *path, char **argv)
   // Commit to the user image.
   oldpgdir = curproc->pgdir;
   curproc->pgdir = pgdir;
-  curproc->shadow_pgdir = setupkvm();
+  curproc->shadow_pgdir = setupkvm(1);
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
diff --git a/mmu.h b/mmu.h
index 1e01fb5..cc2f4f5 100644
--- a/mmu.h
+++ b/mmu.h
@@ -71,7 +71,9 @@ struct segdesc {
 //  \--- PDX(va) --/ \--- PTX(va) --/
 
 // page directory index
-#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
+#define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF) // 0x3FF = 0011 1111 1111(2) 10bit만큼을 1과 and 연산
+#define PD1X(va)        (((uint)(va) >> PD1XSHIFT) & 0x1F) // 0x1F = 0001 1111(2) 5bit
+#define PD2X(va)        (((uint)(va) >> PD2XSHIFT) & 0x1F) // 0x1F = 0001 1111(2) 5bit
 
 // page table index
 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
@@ -81,6 +83,7 @@ struct segdesc {
 
 // construct virtual address from indexes and offset
 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
+#define PG1ADDR(d, c, t, o) ((uint)((d) << PD1XSHIFT | (c) << PD2XSHIFT | (t) << PTXSHIFT | (o)))
 
 // Page directory and page table constants.
 #define NPDENTRIES      1024    // # directory entries per page directory
@@ -89,6 +92,8 @@ struct segdesc {
 
 #define PTXSHIFT        12      // offset of PTX in a linear address
 #define PDXSHIFT        22      // offset of PDX in a linear address
+#define PD1XSHIFT       27
+#define PD2XSHIFT       22
 
 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
@@ -101,7 +106,9 @@ struct segdesc {
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
-#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
+#define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF) // 0xFFF = 1111 1111 1111(2)는 10진수로 4096 12bit만큼을 1과 and 연산
+#define PG1_ADDR(pde)   ((uint)(pde) & ~0x1F) // 0x1F
+#define PG2_ADDR(pde)   ((uint)(pde) & ~0x3FF)
 
 #ifndef __ASSEMBLER__
 typedef uint pte_t;
diff --git a/proc.c b/proc.c
index d866ae8..7583524 100644
--- a/proc.c
+++ b/proc.c
@@ -127,9 +127,9 @@ userinit(void)
   p = allocproc();
   
   initproc = p;
-  if((p->pgdir = setupkvm()) == 0)
+  if((p->pgdir = setupkvm(1)) == 0)
     panic("userinit: out of memory?");
-  p->shadow_pgdir = setupkvm();
+  p->shadow_pgdir = setupkvm(1);
   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
   p->sz = PGSIZE;
   memset(p->tf, 0, sizeof(*p->tf));
@@ -198,7 +198,7 @@ fork(void)
     np->state = UNUSED;
     return -1;
   }
-  np->shadow_pgdir = setupkvm();
+  np->shadow_pgdir = setupkvm(1);
   np->sz = curproc->sz;
   np->parent = curproc;
   *np->tf = *curproc->tf;
@@ -224,6 +224,16 @@ fork(void)
   return pid;
 }
 
+void pvminfo(void){
+  pde_t *ppgdir;
+  struct proc *curproc = myproc();
+  int cur_pid = curproc->pid;
+  ppgdir = curproc->pgdir;
+  //lcr3(V2P(ppgdir));
+  cprintf("current pid: %d\n", cur_pid);
+  printvm(ppgdir);
+}
+
 // Exit the current process.  Does not return.
 // An exited process remains in the zombie state
 // until its parent calls wait() to find out it exited.
diff --git a/syscall.c b/syscall.c
index ee85261..b4e0c12 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_pvminfo(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_pvminfo]   sys_pvminfo,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..d3ddbed 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_pvminfo  22
diff --git a/sysproc.c b/sysproc.c
index 0686d29..460a39d 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,10 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int 
+sys_pvminfo(void)
+{
+  pvminfo();
+  return 0;
+}
\ No newline at end of file
diff --git a/user.h b/user.h
index 4f99c52..a3f123f 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int pvminfo(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..35c9236 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(pvminfo)
\ No newline at end of file
diff --git a/vm.c b/vm.c
index 661c69d..521b0d9 100644
--- a/vm.c
+++ b/vm.c
@@ -29,15 +29,166 @@ seginit(void)
   lgdt(c->gdt, sizeof(c->gdt));
 }
 
+void
+printvm(pde_t *pgdir1)
+{
+  pde_t *pde1;
+  pde_t *pgdir2;
+  pde_t *pde2;
+  pte_t *pgtab;
+  pte_t *pte;
+  int flag = 0;
+  //cprintf("Page directory VA: 0x%p\n", &(*pgdir1));
+  for(int pd1_index = 0; pd1_index < NPDENTRIES; pd1_index++){
+    pde1 = &pgdir1[pd1_index];
+    if(*pde1 & PTE_P){ 
+      if((*pde1 & PTE_U) == 0){
+        continue;
+      }
+      pgdir2 = (pte_t*)P2V(PG2_ADDR(*pde1));
+      for(int pd2_index = 0; pd2_index < NPTENTRIES; pd2_index++){
+        pde2 = &pgdir2[pd2_index];
+        if(*pde2 & PTE_P){
+          if((*pde2 & PTE_U) == 0){
+            continue;
+          }
+          pgtab = (pte_t*)P2V(PTE_ADDR(*pde2));
+          for(int pt_index = 0; pt_index < NPTENTRIES; pt_index++){
+            pte = &pgtab[pt_index];
+            if(*pte & PTE_P){
+              if((*pte & PTE_U) == 0){
+                continue;
+              }
+              if(flag == 0){
+                cprintf("--- %d: pde1 : 0x%p, pa: 0x%p\n", pd1_index, *pde1, V2P(&(*pgdir1)));
+                flag = 1;
+              }
+              if(flag == 1){
+                cprintf("------ %d: pde2 : 0x%p, pa: 0x%p\n", pd2_index, *pde2, V2P(&(*pgdir2)));
+                flag = 2;
+              }
+              if(flag == 2){
+                cprintf("--------- %d: pte : 0x%p, pa: 0x%p\n", pt_index, *pte, V2P(&(*pgtab)));
+              }
+            }
+          }
+          flag = 0;
+        }
+      }
+    }
+  }
+}
+
+static pte_t *
+pde_walkpgdir(pde_t *pgdir1, const void *va, int alloc) // 3 level paging으로 바꾸기
+{
+  pde_t *pde1;
+  pde_t *pde2;
+  pde_t *pgdir2;
+  pte_t *pgtab;
+  //cprintf("walkpgdir\n");
+  pde1 = &pgdir1[PD1X(va)];
+  if(*pde1 & PTE_P){
+    pgdir2 = (pde_t*)P2V(PG1_ADDR(*pde1));
+  } else {
+    if(!alloc || (pgdir2 = (pte_t*)kalloc()) == 0) // kalloc() : 새로운 physical page 할당 
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgdir2, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde1 = V2P(pgdir2) | PTE_P | PTE_W | PTE_U;
+    //return &pgdir2[PD2X(va)];
+  }
+
+  pde2 = &pgdir2[PD2X(va)];
+  if(*pde2 & PTE_P){
+    pgtab = (pte_t*)P2V(PG2_ADDR(*pde2));
+  } else{
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    memset(pgtab, 0, PGSIZE);
+    *pde2 = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    //return 0;
+  }
+  return &pgdir2[PD2X(va)];
+}
+
+static pte_t *
+two_level_walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+  //cprintf("k_walkpgdir\n"); -> 렉먹음
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+  }
+  return &pgtab[PTX(va)];
+}
+
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc) // 3 level paging으로 바꾸기
+{
+  pde_t *pde1;
+  pde_t *pde2;
+  pde_t *pgdir2, *pgdir22;
+  pte_t *pgtab;
+  //cprintf("walkpgdir\n");
+  pde1 = &pgdir[PD1X(va)];
+  if(*pde1 & PTE_P){
+    pgdir2 = (pde_t*)P2V(PTE_ADDR(*pde1)); // PG1_ADDR
+    pgdir22 = (pde_t*)P2V(PG2_ADDR(*pde1));
+    //cprintf("pgdir2 : %p\n", *pgdir2);
+    //cprintf("pgdir22 : %p\n", *pgdir22);
+    
+  } else {
+    if(!alloc || (pgdir2 = (pte_t*)kalloc()) == 0) // kalloc() : 새로운 physical page 할당 
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgdir2, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde1 = V2P(pgdir2) | PTE_P | PTE_W | PTE_U;
+    //return 0;
+    //return &pgdir2[PD2X(va)];
+  }
+
+  pde2 = &pgdir2[PD2X(va)];
+  if(*pde2 & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde2)); // PG2_ADDR
+  } else{
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    memset(pgtab, 0, PGSIZE);
+    *pde2 = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    //return 0;
+  }
+  //cprintf("success\n");
+  //cprintf("pgtab %p\n", &pgtab[PTX(va)]);
+  return &pgtab[PTX(va)];
+}
+
 // Return the address of the PTE in page table pgdir
 // that corresponds to virtual address va.  If alloc!=0,
 // create any required page table pages.
 static pte_t *
-walkpgdir(pde_t *pgdir, const void *va, int alloc)
+k_walkpgdir(pde_t *pgdir, const void *va, int alloc)
 {
   pde_t *pde;
   pte_t *pgtab;
-
+  //cprintf("k_walkpgdir\n"); -> 렉먹음
   pde = &pgdir[PDX(va)];
   if(*pde & PTE_P){
     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
@@ -58,16 +209,23 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
 static int
-mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
+mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm, int is_kernel)
 {
   char *a, *last;
   pte_t *pte;
-
   a = (char*)PGROUNDDOWN((uint)va);
   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
   for(;;){
-    if((pte = walkpgdir(pgdir, a, 1)) == 0)
-      return -1;
+    if(is_kernel == 1){
+      if((pte = k_walkpgdir(pgdir, a, 1)) == 0){
+        return -1;
+      }
+    }
+    else{
+      if((pte = walkpgdir(pgdir, a, 1)) == 0){
+        return -1;
+      } 
+    }
     if(*pte & PTE_P)
       panic("remap");
     *pte = pa | perm | PTE_P;
@@ -116,7 +274,7 @@ static struct kmap {
 
 // Set up kernel part of a page table.
 pde_t*
-setupkvm(void)
+setupkvm(int is_kernel)
 {
   pde_t *pgdir;
   struct kmap *k;
@@ -128,7 +286,7 @@ setupkvm(void)
     panic("PHYSTOP too high");
   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
-                (uint)k->phys_start, k->perm) < 0) {
+                (uint)k->phys_start, k->perm, is_kernel) < 0) {
       freevm(pgdir);
       return 0;
     }
@@ -140,7 +298,7 @@ setupkvm(void)
 void
 kvmalloc(void)
 {
-  kpgdir = setupkvm();
+  kpgdir = setupkvm(1);
   switchkvm();
 }
 
@@ -188,7 +346,7 @@ inituvm(pde_t *pgdir, char *init, uint sz)
     panic("inituvm: more than a page");
   mem = kalloc();
   memset(mem, 0, PGSIZE);
-  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
+  mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U, 0);
   memmove(mem, init, sz);
 }
 
@@ -238,7 +396,7 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       return 0;
     }
     memset(mem, 0, PGSIZE);
-    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
+    if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U, 0) < 0){
       cprintf("allocuvm out of memory (2)\n");
       deallocuvm(pgdir, newsz, oldsz);
       kfree(mem);
@@ -248,24 +406,80 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   return newsz;
 }
 
+int
+deallocuvm2(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  pte_t *pte;
+  pde_t *pde; // revised by koo
+  uint a, pa;
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+  //cprintf("--------start deallocuvm2--------\n");
+  for(; a < oldsz; a += PGSIZE){
+    pte = walkpgdir(pgdir, (char*)a, 0);
+    if(!pte){
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+      //a = PG1ADDR(PD1X(a) + 1, 0, 0, 0) - PGSIZE;
+    }
+      
+    else if((*pte & PTE_P) != 0){
+      pa = PTE_ADDR(*pte);
+      if(pa == 0)
+        panic("kfree");
+      char *v = P2V(pa);
+      kfree(v);
+      *pte = 0;
+    }
+  }
+  //cprintf("--------finish deallocuvm2--------\n");
+  return newsz;
+}
+
 // Deallocate user pages to bring the process size from oldsz to
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
 int
-deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz) // deallocuvm(pgdir, KERNBASE, 0);
 {
   pte_t *pte;
+  pde_t *pde; // revised by koo
   uint a, pa;
 
   if(newsz >= oldsz)
     return oldsz;
 
   a = PGROUNDUP(newsz);
-  for(; a  < oldsz; a += PGSIZE){
+  //deallocuvm2(pgdir, KERNBASE, 0);
+  //cprintf("--------start deallocuvm--------\n");
+  for(; a < oldsz; a += PGSIZE*1024){
+    
     pte = walkpgdir(pgdir, (char*)a, 0);
-    if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+    if(!pte){
+      //a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+      // 여기서부터 추가함
+
+      a = PG1ADDR(PD1X(a) + 1, 0, 0, 0) - PGSIZE;
+      // for(; a  < oldsz; a += PGSIZE){
+      //   cprintf("################\n");
+      //   pde = pde_walkpgdir(pgdir, (char*)a, 0);
+      //   if(!pde)
+      //     a = PG1ADDR(PD1X(a), PD2X(a) + 1, 0, 0) - PGSIZE;
+      //   else if((*pde & PTE_P) != 0){
+      //     pa = PG1_ADDR(*pde);
+      //     if(pa == 0)
+      //       panic("kfree");
+      //     char *v = P2V(pa);
+      //     kfree(v);
+      //     *pde = 0;
+      //   }
+      // }
+      // 여기까지
+    }
+      
     else if((*pte & PTE_P) != 0){
       pa = PTE_ADDR(*pte);
       if(pa == 0)
@@ -275,16 +489,14 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       *pte = 0;
     }
   }
+  //cprintf("--------finish deallocuvm--------\n");
   return newsz;
 }
 
-// Free a page table and all the physical memory pages
-// in the user part.
 void
-freevm(pde_t *pgdir)
+freevm_original(pde_t *pgdir)
 {
   uint i;
-
   if(pgdir == 0)
     panic("freevm: no pgdir");
   deallocuvm(pgdir, KERNBASE, 0);
@@ -297,13 +509,53 @@ freevm(pde_t *pgdir)
   kfree((char*)pgdir);
 }
 
+// Free a page table and all the physical memory pages
+// in the user part.
+void
+freevm(pde_t *pgdir)
+{
+  uint i, j;
+  pde_t *pde1, *pde2;
+  pde_t *pgdir2;
+  pte_t *pgtab;
+  if(pgdir == 0)
+    panic("freevm: no pgdir");
+  //cprintf("--------freevm--------\n");
+  deallocuvm(pgdir, KERNBASE, 0);
+  //cprintf("--------finish freevm--------\n");
+  for(i = 0; i < 32; i++){ //NPDENTRIES
+    if(pgdir[i] & PTE_P){
+      // char * v = P2V(PTE_ADDR(pgdir[i]));
+      // kfree(v);
+
+      /////////////////////////////////////
+      pde1 = &pgdir[i];
+      pgdir2 = (pde_t*)P2V(PG1_ADDR(*pde1));
+
+      for(j = 0; j < 32; j++){
+        if(pgdir2[j] & PTE_P){
+          pde2 = &pgdir2[j];
+          //pgtab = (pde_t*)P2V(PTE_ADDR(*pde2));
+          char * v2 = P2V(PTE_ADDR(pgdir2[j]));
+          //cprintf("--------kfree v2-------\n");
+          kfree(v2);
+        }
+      }
+      char * v = P2V(PG2_ADDR(pgdir[i]));
+      kfree(v);
+      /////////////////////////////////////
+
+    }
+  }
+  kfree((char*)pgdir);
+}
+
 // Clear PTE_U on a page. Used to create an inaccessible
 // page beneath the user stack.
 void
 clearpteu(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
-
   pte = walkpgdir(pgdir, uva, 0);
   if(pte == 0)
     panic("clearpteu");
@@ -320,7 +572,7 @@ copyuvm(pde_t *pgdir, uint sz)
   uint pa, i, flags;
   char *mem;
 
-  if((d = setupkvm()) == 0)
+  if((d = setupkvm(0)) == 0)
     return 0;
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
@@ -332,7 +584,7 @@ copyuvm(pde_t *pgdir, uint sz)
     if((mem = kalloc()) == 0)
       goto bad;
     memmove(mem, (char*)P2V(pa), PGSIZE);
-    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
+    if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags, 0) < 0) {
       kfree(mem);
       goto bad;
     }
@@ -350,7 +602,6 @@ char*
 uva2ka(pde_t *pgdir, char *uva)
 {
   pte_t *pte;
-
   pte = walkpgdir(pgdir, uva, 0);
   if((*pte & PTE_P) == 0)
     return 0;
@@ -450,7 +701,7 @@ void pagefault(void)
   *pde = *pde_origin;
   //clprintf("Allocated pgtable at 0x%p\n", pte);
 
-  pte = walkpgdir(proc->shadow_pgdir, 0, 1); ///////// walkpgdir로 바꾸기
+  pte = k_walkpgdir(proc->shadow_pgdir, 0, 1); ///////// walkpgdir로 바꾸기
   pte_origin = walkpgdir(proc->pgdir, 0, 1);
   *pte = *pte_origin;
   clprintf("Allocated pgtable at 0x%p\n", pte);
