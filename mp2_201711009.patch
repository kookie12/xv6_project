diff --git a/proc.c b/proc.c
index 806b1b1..1e556eb 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->context_switch_num = 0;
 
   release(&ptable.lock);
 
@@ -260,7 +261,7 @@ exit(void)
         wakeup1(initproc);
     }
   }
-
+  
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
@@ -325,33 +326,41 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+
   for(;;){
-    // Enable interrupts on this processor.
+    // Enable interrupts on this processor. 
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    
+    //scheduler thread find runnable process - koo
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){	    
+      	    
       if(p->state != RUNNABLE)
         continue;
-
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
-      switchuvm(p);
+      switchuvm(p); //load runnable process (in user space) into kernel  
       p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
+      
+      // scheduler find process!
+      // swtch() store current process context into PCB which means p->context and call sched() - koo
+      swtch(&(c->scheduler), p->context); //it order processor switch process (in user space) to excute
+      switchkvm(); //after swtch() in sched(), scheduler load info (register..) into kernel 
+      
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+      
+      p->context_switch_num += 1;
+      if(p->state == ZOMBIE){
+      	cprintf("\n%s(%d) performed %d context switches\n", p->name, p->pid,  p->context_switch_num); 	
+      }
     }
-    release(&ptable.lock);
-
+    release(&ptable.lock); 
   }
 }
 
@@ -377,7 +386,7 @@ sched(void)
   if(readeflags()&FL_IF)
     panic("sched interruptible");
   intena = mycpu()->intena;
-  swtch(&p->context, mycpu()->scheduler);
+  swtch(&p->context, mycpu()->scheduler);//this code order scheduller into kernel!
   mycpu()->intena = intena;
 }
 
diff --git a/proc.h b/proc.h
index 1647114..dca5ab2 100644
--- a/proc.h
+++ b/proc.h
@@ -48,7 +48,8 @@ struct proc {
   int killed;                  // If non-zero, have been killed
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+  char name[16];               // Process name (debugging) name[16]
+  int context_switch_num;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..487add3 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,8 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_getcswitch(void);
+extern int sys_setcswitch(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +128,8 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_getcswitch]   sys_getcswitch,
+[SYS_setcswitch]   sys_setcswitch,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..4ad0359 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_getcswitch  22
+#define SYS_setcswitch  23
diff --git a/sysproc.c b/sysproc.c
index 0686d29..779b0cd 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,23 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int 
+sys_getcswitch(void)
+{  
+  return myproc()->context_switch_num;
+}
+
+int 
+sys_setcswitch(void)
+{
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  
+  myproc()->context_switch_num = n;
+  return 0;
+}
+
+
diff --git a/user.h b/user.h
index 4f99c52..656fe9f 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int getcswitch(void);
+int setcswitch(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..dfd8d62 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(getcswitch)
+SYSCALL(setcswitch)
