diff --git a/proc.c b/proc.c
index 806b1b1..4bd4ecf 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,7 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->context_switch_num = 0;
 
   release(&ptable.lock);
 
@@ -260,7 +261,7 @@ exit(void)
         wakeup1(initproc);
     }
   }
-
+  
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
@@ -325,33 +326,41 @@ scheduler(void)
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+
   for(;;){
-    // Enable interrupts on this processor.
+    // Enable interrupts on this processor. 
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    
+    //scheduler thread find runnable process - koo
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){	    
+      	    
       if(p->state != RUNNABLE)
         continue;
-
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
+      
+      // scheduler find process!
+      // swtch() store current process context into PCB which means p->context and call sched() - koo
+      swtch(&(c->scheduler), p->context); //going into kernel mode!! scheduler get cpu from RUNNING process - koo
       switchkvm();
-
+      
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+      
+      p->context_switch_num += 1;
+      if(p->state == ZOMBIE && p->name[0] == 'e' &&  p->name[1] == 'c' && p->name[2] == 'h' && p->name[3] == 'o'){
+      	cprintf("\n%s(%d) performed %d context switches\n", p->name, p->pid,  p->context_switch_num); 	
+      }
     }
-    release(&ptable.lock);
-
+    release(&ptable.lock); 
   }
 }
 
diff --git a/proc.h b/proc.h
index 1647114..dca5ab2 100644
--- a/proc.h
+++ b/proc.h
@@ -48,7 +48,8 @@ struct proc {
   int killed;                  // If non-zero, have been killed
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
-  char name[16];               // Process name (debugging)
+  char name[16];               // Process name (debugging) name[16]
+  int context_switch_num;
 };
 
 // Process memory is laid out contiguously, low addresses first:
